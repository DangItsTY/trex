<html>
<head>
<title>Zombie Survival Online</title>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
	<div id = "writeup" style="display:none;">
		<!--	
			~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
			Write up
			~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		-->
		Infinite Zombie Apocalypse - by Ty Dang (btd3wb) 5/4/2015
		
		This project's goal was to create a simple zombie survival game in 3D.
		For computer graphics, this project's focus was towards utilizing WebGL and Three.js
		to produce some funny effects and custom shaders.
		
		All of the code is made "from scratch" and small snippits were grabbed from tutorials (thanks google!)
		Example of code snippits included the hello world for Three.js and bare minimum webgl text for the vertex
		and fragment shader.
		
		The game includes the following features:
			-	Movement controls (WASD)
			-	Looking around (QE)
			-	Shooting (spacebar)
			Note: you can display controls at any time by pressing 'P'!
			-	Simple ai
			-	A bullet that has two spheres attached spiraling around the bullet
			-	Zombies created from a box attached to a sphere
			-	Zombies die upon bullet collision and "explode". This explosion
				was done by using the normals of the box to "pop" out (using some webgl elements)
				in accordance to the death animation timer.
			-	Zombies had funky heads. I applied a custom shader to both the body and head with directional light.
				The head had a "bumpmap" associated with all of its vertices given a random value and
				this moved up and down according to a sin function
			-	Score counter (keeps track of zombies killed)
			-	Player health (game over screen occurs once player reaches 0 health)
			-	Player hit collision detection (screen flashes red for 1 second, also player is
				invulnerable at this time)
			-	Spawner object that spawns zombies faster with higher score
			-	Displays "Awesome!" message every 10 kills
			-	Collision detection
		Thank you, have fun!
	</div>
	<div id = "mask" style="position:fixed; width:100%; height:100%; opacity:0.8; background-color:#ff0000"></div>
	<div id = "cursor" style="position:fixed; top:50%; left:50%; width:4px; height:4px; background-color:#ffffff"></div>
	<div id = "gameover" style="position:fixed; width:100%; height:100%; opacity:0.8; background-color:#ff0000; display:none;"></div>
	<div id = "gameover_message" style="position:fixed; top:40%; left:40%; color:#ffffff; font-size:50pt; display:none;">Game Over!</div>
	<div id = "score" style="position:absolute; top:10px; left:10px; color:#00aa00; font-size:20pt;">Score: 0</div>
	<div id = "health" style="position:absolute; top:40px; left:10px; color:#aa0000; font-size:20pt;">Health: 10</div>
	<div id = "controls" style="position:absolute; top:10px; right:10px; color:#0000aa; font-size:20pt; display:none;">
		Controls:<br>
		WASD - Move<br>
		QE - Look<br>
		Space - Shoot<br>
	</div>
	<div id = "message" style="position:fixed; top:40%; left:40%; color:#ffffff; font-size:50pt;"></div>
	<div id = 'vertexShader' style="display:none;">
		uniform float explode;
		uniform float bumpy;
		attribute float bumpmap;
		varying vec3 vNormal;
		void main() {
			vNormal = normal;
			vec3 newPosition = position + normal*vec3(explode, explode, explode) + normal*vec3(bumpy*bumpmap, bumpy*bumpmap, bumpy*bumpmap);
			gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,1.0);
		}
	</div>
	<div id = 'fragmentShader' style="display:none;">
		uniform float r;
		uniform float g;
		uniform float b;
		varying vec3 vNormal;
		void main() {
			vec3 light = vec3(1.0, 1.0, 1.0);			  
			light = normalize(light);
			float dProd = max(0.1, dot(vNormal, light)+0.1);
			gl_FragColor = vec4(dProd*r, dProd*g, dProd*b, 1.0);
		}
	</div>
	<script src="js/three.min.js"></script>
	<script>
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		//	Game variables
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		var score = 0;	//	How many zombies killed
		var showControls = false;	//	Show controls toggle with 'P'
		var playerhealth = 10;	//	game over if this is 0
		var invincibility = 1;	//	if hit, you are invincible for 1 second
		
		
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		//	Set up keyboard controls
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		var keysDown = {};	//	Holds a list of all keys that are down
		var keysUp = {};	//	Keys that are released
		addEventListener("keydown", function (e) {
			keysDown[e.keyCode] = true;
		}, false);
		addEventListener("keyup", function (e) {
			keysUp[e.keyCode] = true;
			delete keysDown[e.keyCode];
		}, false);
		document.addEventListener("mousedown", mouseDown, false);		//	Note, detecting for left click requires these few functions. Added a special index "leftclick" for keysDown and keysUp
		function mouseDown() {
			keysDown["leftclick"] = true;
		}
		document.addEventListener("mouseup", mouseUp, false);
		function mouseUp() {
			keysDown["leftclick"] = false;
		}
		document.addEventListener('mousemove', function(evt) {
			mousePos = getMousePos(canvas, evt);
		}, false);

		//	Key Mapping
		var key = new Array();
		key["up"] = 87;
		key["down"] = 83;
		key["left"] = 65;
		key["right"] = 68;
		key["y"] = 78;
		key["x"] = 74;
		key["b"] = 69;
		key["a"] = 81;
		key["l"] = 16;
		key["r"] = 186;
		key["start"] = 80;
		key["select"] = 13;
		key["spacebar"] = 32;
			
		
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		//	Objects
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*		
		var objectList = new Array();
		var oCount = 0;
		
		var bullet = function(x, y, z) {
			this.type = "bullet";
			this.x = x;
			this.y = y;
			this.z = z;
			this.speed = 0.5;
			this.life = 0;
			this.maxlife = 100;	//	counted by distance travelled
			this.angle = camera.rotation.y;	//	the direction to shoot
			this.health = 1;
			this.act = function(object) { aibullet(object); aimove(object); };
			this.deathtimer = 0.0;
			this.lifetimer = 0.0;

			
			var geometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );
			var material = new THREE.MeshBasicMaterial( { color: 0x93FFE9 } );
			var bullet = new THREE.Mesh( geometry, material );
			scene.add(bullet);	//	Note there will be a bug if zombies appear at 0,0,0
			bullet.position.x = x;
			bullet.position.y = y;
			bullet.position.z = z;
			
			var geometry = new THREE.SphereGeometry( 0.25, 8, 6 );
			var material = new THREE.MeshBasicMaterial( { color: 0xFF82CD } );
			var bullet2 = new THREE.Mesh( geometry, material );
			scene.add(bullet2);	//	Note there will be a bug if zombies appear at 0,0,0
			bullet2.position.x = bullet.position.x + 0.5;
			bullet2.position.y = bullet.position.y;
			bullet2.position.z = bullet.position.z;
			
			var geometry = new THREE.SphereGeometry( 0.25, 8, 6 );
			var material = new THREE.MeshBasicMaterial( { color: 0xFF82CD } );
			var bullet3 = new THREE.Mesh( geometry, material );
			scene.add(bullet3);	//	Note there will be a bug if zombies appear at 0,0,0
			bullet3.position.x = bullet.position.x - 0.5;
			bullet3.position.y = bullet.position.y;
			bullet3.position.z = bullet.position.z;
			
			this.mesh = new Array();
			this.meshx = new Array();
			this.meshy = new Array();
			this.meshz = new Array();
			this.mesh.push(bullet);
			this.meshx.push(0);
			this.meshy.push(0);
			this.meshz.push(0);
			this.mesh.push(bullet2);
			this.meshx.push(0);
			this.meshy.push(0);
			this.meshz.push(0);
			this.mesh.push(bullet3);
			this.meshx.push(0);
			this.meshy.push(0);
			this.meshz.push(0);
						
			oCount++;
		};
		
		var zombie = function(x, y, z) {
			this.type = "zombie";
			this.x = x;
			this.y = y;
			this.z = z;
			this.speed = 0.01;
			this.health = 1;
			this.act = function(object) { aimove(object); aifollow(object); animateZombieHead(object); };
			this.deathtimer = 0.5;
			this.lifetimer = 0.0;	//	how long it's been alive
			
			//	Head
			var uniforms = {
				bumpy: {type: 'f', value: 1.0},
				explode: {type: 'f', value: 0.0},
				r: {type: 'f', value: 0.75},
				g: {type: 'f', value: 0.0},
				b: {type: 'f', value: 0.0}
			};
			var attributes = {
				bumpmap: {type: 'f', value: []}
			};
			var geometry = new THREE.SphereGeometry(1.0, 24, 24);
			var vertices = geometry.vertices;
			var values = attributes.bumpmap.value
			for(var v = 0; v < vertices.length; v++) {
				values.push(Math.random() * 0.2);
			}
			var material = new THREE.ShaderMaterial( {
				uniforms: uniforms,
				attributes: attributes,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );
			var object = new THREE.Mesh( geometry, material );
			scene.add( object );
			object.position.x = x;
			object.position.y = y;
			object.position.z = z;
			
			//	Body
			var uniforms = {
				bumpy: {type: 'f', value: 0.0},
				explode: {type: 'f', value: 0.0},
				r: {type: 'f', value: 0.0},
				g: {type: 'f', value: 0.75},
				b: {type: 'f', value: 0.0}
			};
			var attributes = {
				bumpmap: {type: 'f', value: []}
			};
			var geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
			var vertices = geometry.vertices;
			var values = attributes.bumpmap.value
			for(var v = 0; v < vertices.length; v++) {
				values.push(Math.random() * 0);
			}
			var material = new THREE.ShaderMaterial( {
				uniforms: uniforms,
				attributes: attributes,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );
			var object2 = new THREE.Mesh( geometry, material );
			scene.add(object2);
			object2.position.x = object.position.x;
			object2.position.y = object.position.y - 1;
			object2.position.z = object.position.z;
			
			//	The mesh array holds all body parts
			//	Each mesh(x, y, z) holds values to displace the body parts
			this.mesh = new Array();
			this.meshx = new Array();
			this.meshy = new Array();
			this.meshz = new Array();
			this.mesh.push(object);
			this.meshx.push(0);
			this.meshy.push(0);
			this.meshz.push(0);
			this.mesh.push(object2);
			this.meshx.push(0);
			this.meshy.push(-1);
			this.meshz.push(0);

			oCount++;
		};
		
		var spawner = function(x, y, z) {
			this.type = "spawner";
			this.x = x;
			this.y = y;
			this.z = z;
			this.speed = 0;
			this.health = 1;
			this.act = function(object) { aispawnzombies(object); };
			this.deathtimer = 1.0;
			this.lifetimer = 0.0;
			
			oCount++;
		};
		
		
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		//	Functions
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*

		//	Spawns the given amount of zombies in a 20x20 area around center
		var spawnZombies = function(amount) {
			for (var i = 0; i < amount; i++) {
				var randx = 0;
				var randz = 0;
				var rand = Math.floor((Math.random() * 2)) + 1;
				if (rand == 1)
					randx = Math.floor((Math.random() * 20)) + 1;
				else
					randx = -Math.floor((Math.random() * 20)) + 1;
				rand = Math.floor((Math.random() * 2)) + 1;
				if (rand == 1)
					randz = Math.floor((Math.random() * 20)) + 1;
				else
					randz = -Math.floor((Math.random() * 20)) + 1;
				objectList[i] = new zombie(randx, 0, randz);
			}
		};
		
		//	call act on all objects
		var actAll = function() {
			for (var i = 0; i < oCount; i++) {
				objectList[i].act(objectList[i]);
				objectList[i].lifetimer += modifier;	//	keep track of how long object is alive
			}
		};
		
		//	remove objects that need to die
		var checkDeath = function() {
			for (var i = 0; i < oCount; i++) {
				//	Tick death animation
				if (objectList[i].health <= 0 && objectList[i].deathtimer >= 0) {
					objectList[i].deathtimer -= modifier;
					if (objectList[i].type == "zombie") {
						animateZombieDeath(objectList[i]);
					}
				}
					//	Kill projectile if their life time has expired
				if (objectList[i].life >= objectList[i].maxlife ||
					//	Kill any entity whose health is below zero & animation death is over
					(objectList[i].health <= 0 && objectList[i].deathtimer <= 0)) {
					
					for (var j = 0; j < objectList[i].mesh.length; j++) {
						scene.remove(objectList[i].mesh[j]);
					}
					objectList.splice(i, 1);
					oCount -= 1;
					i -= 1;
				}
			}
		};
		
		var animateZombieDeath = function(object) {
			object.mesh[1].material.uniforms.explode.value += modifier*2;
		};
		
		var animateZombieHead = function(object) {
			var speed = 10.0;
			object.mesh[0].material.uniforms.bumpy.value = Math.sin(object.lifetimer*speed);
		};
		
		var invincibilitytimer = function() {
			if (invincibility >= 0) {
				invincibility -= modifier;
				document.getElementById("mask").style.opacity = 0.8 * invincibility;
			}
		};
		
		//	A simple box collision test
		var collision = function(object, target) {
			var hitbox = 1;
			if (object.x < target.x + hitbox && object.x > target.x -hitbox &&
				object.z < target.z + hitbox && object.z > target.z -hitbox) {
				return true;
			} else {
				return false;
			}
		}
		
		//	Resolve collisions
		var checkAllCollisions = function() {
			var hitbox = 1;
			for (var i = 0; i < oCount; i++) {
				for (var j = i+1; j < oCount; j++) {
					if (collision(objectList[i], objectList[j])) {
						//	Bullet hits zombie
						if ((objectList[i].type == "bullet" || objectList[j].type == "bullet") &&
							(objectList[i].type == "zombie" || objectList[j].type == "zombie")) {
							objectList[i].health = 0;
							objectList[j].health = 0;
							score += 1;
						}
					}
					//	If zombie hits player
					//	too lazy to make an actual object
					if (objectList[i].type == "zombie" &&
						invincibility <= 0 &&
						objectList[i].x < camera.position.x + hitbox &&
						objectList[i].x > camera.position.x - hitbox &&
						objectList[i].z < camera.position.z + hitbox &&
						objectList[i].z > camera.position.z - hitbox) {
						playerhealth -= 1;
						invincibility = 1;
						if (playerhealth <= 0) {
							doGameOver();
						}
					}
				}
			}
		}
		
		var doGameOver = function() {
			document.getElementById("gameover").style.display = "inline-block";
			document.getElementById("gameover_message").style.display = "inline-block";
			document.getElementById("gameover_message").innerHTML = "Game Over!<br>Score: " + score;
			document.getElementById("message").style.display = "none";
		}
		
		var displayScore = function() {
			document.getElementById("score").innerHTML = "Score: " + score;
		}
		var displayHealth = function() {
			document.getElementById("health").innerHTML = "Health: " + playerhealth;
		}
		var displayMessage = function() {
			if (score % 10 == 0 && score != 0) {
				document.getElementById("message").innerHTML = "AWESOME!";
			}
			else {
				document.getElementById("message").innerHTML = "";
			}
		}
		var displayControls = function() {
			if (showControls) {
				document.getElementById("controls").style.display = "inline-block";
			} else {
				document.getElementById("controls").style.display = "none";
			}
		}
		
		
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		//	AI
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		
		//	A simple ai to follow player (aka the camera)
		//	lol they move faster at diagonals. math hacks.
		var aifollow = function(object) {
			if (object.z < camera.position.z)
				object.z += object.speed;
			else
				object.z -= object.speed;
			if (object.x < camera.position.x)
				object.x += object.speed;
			else
				object.x -= object.speed;
		};
		
		//	shoots a bullet with spiralling spheres
		var aibullet = function(object) {
			object.x += -object.speed*Math.sin(object.angle);
			object.z += -object.speed*Math.cos(object.angle);
			object.meshx[1] = Math.sin(object.lifetimer*10)/2;
			object.meshy[1] = Math.cos(object.lifetimer*10)/2;
			object.meshx[2] = Math.sin(object.lifetimer*10+(Math.PI/1))/2;
			object.meshy[2] = Math.cos(object.lifetimer*10+(Math.PI/1))/2;
			
			object.life += object.speed;
		}
		
		//	this does the literal movement of the object, rendered by webgl
		var aimove = function(object) {
			for (var i = 0; i < object.mesh.length; i++) {
				object.mesh[i].position.x = object.x + object.meshx[i];
				object.mesh[i].position.y = object.y + object.meshy[i];
				object.mesh[i].position.z = object.z + object.meshz[i];
			}
		}
		
		//	Spawn zombies in a 20x20 area with increasing frequency as score gets higher
		var aispawnzombies = function(object) {
			var frequency = Math.floor(Math.random()*1000) + 1;
			if (frequency <= (score/10)+10) {
				var randx = 0;
				var randz = 0;
				var rand = Math.floor((Math.random() * 2)) + 1;
				if (rand == 1)
					randx = Math.floor((Math.random() * 20)) + 1;
				else
					randx = -Math.floor((Math.random() * 20)) + 1;
				rand = Math.floor((Math.random() * 2)) + 1;
				if (rand == 1)
					randz = Math.floor((Math.random() * 20)) + 1;
				else
					randz = -Math.floor((Math.random() * 20)) + 1;
				objectList[oCount] = new zombie(object.x + randx, 0, object.z + randz);
			}
		};
		
		
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		//	Controls
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		var runControls = function() {
			//	Move
			//	First check diagonal movement
			var applyDiagonal = 1;
			if ((key["up"] in keysDown || key["down"] in keysDown) && (key["right"] in keysDown || key["left"] in keysDown)) {
				applyDiagonal = 1 / Math.sqrt(2);
			}
			if (key["up"] in keysDown) {
				camera.position.z += -0.1*Math.cos(camera.rotation.y) * applyDiagonal;
				camera.position.x += -0.1*Math.sin(camera.rotation.y) * applyDiagonal;
			}
			if (key["down"] in keysDown) {
				camera.position.z += 0.1*Math.cos(camera.rotation.y) * applyDiagonal;
				camera.position.x += 0.1*Math.sin(camera.rotation.y) * applyDiagonal;
			}
			if (key["left"] in keysDown) {
				camera.position.z += 0.1*Math.sin(camera.rotation.y) * applyDiagonal;
				camera.position.x += -0.1*Math.cos(camera.rotation.y) * applyDiagonal;
			}
			if (key["right"] in keysDown) {
				camera.position.z += -0.1*Math.sin(camera.rotation.y) * applyDiagonal;
				camera.position.x += 0.1*Math.cos(camera.rotation.y) * applyDiagonal;
			}
			
			//	Shoot!
			if (key["spacebar"] in keysDown && !(key["spacebar"] in keysUp)) {
				//	shoot!
				//	Note player = camera
				objectList[oCount] = new bullet(camera.position.x, camera.position.y, camera.position.z);
				keysUp[key["spacebar"]] = true;
			}
			
			//	Rotate camera
			if (key["a"] in keysDown) {
				camera.rotation.y += 0.02;
			}
			if (key["b"] in keysDown) {
				camera.rotation.y += -0.02;
			}
			
			//	Show/Hide controls
			if (key["start"] in keysDown && !(key["start"] in keysUp)) {
				if (!showControls) {
					showControls = true;
				} else {
					showControls = false;
				}
				keysUp[key["start"]] = true;
			}
			
			//	Release keys (for the purpose of toggling, holding, different modes of controls, etc.)
			if (!(key["up"] in keysDown)) {
				delete keysUp[key["up"]];
			}
			if (!(key["down"] in keysDown)) {
				delete keysUp[key["down"]];
			}
			if (!(key["left"] in keysDown)) {
				delete keysUp[key["left"]];
			}
			if (!(key["right"] in keysDown)) {
				delete keysUp[key["right"]];
			}
			if (!(key["spacebar"] in keysDown)) {
				delete keysUp[key["spacebar"]];
			}
			if (!(key["a"] in keysDown)) {
				delete keysUp[key["a"]];
			}
			if (!(key["b"] in keysDown)) {
				delete keysUp[key["b"]];
			}
			if (!(key["start"] in keysDown)) {
				delete keysUp[key["start"]];
			}
		};
		
		
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		//	Render the game!
		//	~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
		
		//	Initialize the scene
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		camera.position.z = 5;
		
		//	Draw a cube to mark center
		var geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
		var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
		var cube = new THREE.Mesh(geometry, material);
		scene.add(cube);
		
		//	Any initializations go here
		var init = function() {
			spawnZombies(2);
			objectList[oCount] = new spawner(0, 0, 0);
		};
		init();
		
		time_then = Date.now();
		
		//	Finally render! This is also the game loop
		function render() {
			requestAnimationFrame( render );
			
			
			//	cool cube rotation
			cube.rotation.x += 0.01;
			cube.rotation.y += 0.01;
			
			//	calculate delta frame time
			time_now = Date.now();
			time_delta = time_now - time_then;
			modifier = time_delta/1000;
			time_then = time_now;

			runControls();
			actAll();
			checkAllCollisions();
			checkDeath();
			displayScore();
			displayHealth();
			displayMessage();
			displayControls();
			invincibilitytimer();
		
		
			renderer.render( scene, camera );
		}
		render();
	</script>
</body>
</html>